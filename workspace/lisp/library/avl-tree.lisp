(defpackage :avl-tree
  (:use :cl)
  (:export
   :define-avl-set))

(in-package :avl-tree)

(defmacro define-avl-set (struct-name
			   &key
			     (conc-name struct-name)
			     (compare #'<)
			     (element-type '*))
  (let* ((set struct-name)
	 (node (intern (format nil "~:@(~a-node~)" conc-name)))
	 (make-node (intern (format nil "~:@(make-~a~)" node)))
	 (node-left-child (intern (format nil "~:@(~a-left-child~)" node)))
	 (node-right-child (intern (format nil "~:@(~a-right-child~)" node)))
	 (node-value (intern (format nil "~:@(~a-value~)" node)))
	 (node-height (intern (format nil "~:@(~a-height~)" node)))
	 (node-update-height (intern (format nil "~:@(~a-update-height~)" node)))
	 (node-rotate-left (intern (format nil "~:@(~a-rotate-left~)" node)))
	 (node-rotate-right (intern (format nil "~:@(~a-rotate-right~)" node)))
	 (node-balance (intern (format nil "~:@(~a-balance~)" node)))
	 (node-make-balance-left (intern (format nil "~:@(~a-make-balance-left~)" node)))
	 (node-make-balance-right (intern (format nil "~:@(~a-make-balance-right~)" node)))
	 (%make-set (intern (format nil "~:@(%make-~a~)" conc-name)))
	 (make-set (intern (format nil "~:@(make-~a~)" conc-name)))
	 (set-insert (intern (format nil "~:@(~a-insert~)" conc-name)))
	 (set-erase (intern (format nil "~:@(~a-erase~)" conc-name)))
	 (set-find (intern (format nil "~:@(~a-find~)" conc-name)))
	 (set-has (intern (format nil "~:@(~a-has~)" conc-name)))
	 (set-size (intern (format nil "~:@(~a-size~)" conc-name))))
    `(progn
       (defstruct ,node
	 (left-child nil :type (or null ,node))
	 (right-child nil :type (or null ,node))
	 (value nil :type ,element-type)
	 (height 0 :type (integer 0)))
       (defun ,node-update-height (node)
	 (declare (,node node))
	 (with-slots (height left-child right-child) node
	   (setf height
		 (max (if left-child (1+ (,node-height left-child)) 0)
		      (if right-child (1+ (,node-height right-child)) 0)))))
       (defun ,node-balance (node)
	 (declare (,node node))
	 (with-slots (left-child right-child) node
	   (- (if right-child (,node-height right-child) 0)
	      (if left-child (,node-height left-child) 0))))
       (defun ,node-rotate-right (node)
	 (declare (,node node))
	 (let* ((left (,node-left-child node))
		(right (,node-right-child left)))
	   (setf (,node-left-child node) right)
	   (setf (,node-right-child left) node)
	   (,node-update-height node)
	   (,node-update-height left)
	   left))
       (defun ,node-rotate-left (node)
	 (declare (,node node))
	 (let* ((right (,node-right-child node))
		(left (,node-left-child right)))
	   (setf (,node-right-child node) left)
	   (setf (,node-left-child right) node)
	   (,node-update-height node)
	   (,node-update-height right)
	   right))
       (defun ,node-make-balance-left (node)
	 (declare (,node node))
	 (cond ((<= 2 (,node-balance node))
		(let ((right (,node-right-child node)))
		  (when (<= (,node-balance right) -1)
		    (setf (,node-right-child node) (,node-rotate-right right)))
		  (,node-rotate-left node)))
	       (t node)))
       (defun ,node-make-balance-right (node)
	 (declare (,node node))
	 (cond ((<= (,node-balance node) -2)
		(let ((left (,node-left-child node)))
		  (when (<= 1 (,node-balance left))
		    (setf (,node-left-child node) (,node-rotate-left left)))
		  (,node-rotate-right node)))
	       (t node)))
       (defstruct (,set (:constructor ,%make-set))
	 (root nil :type (or null ,node))
	 (count 0 :type (integer 0)))
       (defun ,make-set ()
	 (,%make-set :root nil :count 0))
       (defun ,set-insert (set key)
	 (declare (,set set) (,element-type key))
	 (with-slots (count root) set
	   (labels ((rec (node)
		      (declare ((or null ,node) node))
		      (unless node
			(incf count)
			(return-from rec (,make-node :value key)))
		      (with-slots (left-child right-child value) node
			(cond ((funcall ,compare key value)
			       (setf left-child (rec left-child))
			       (,node-update-height node)
			       (,node-make-balance-right node))
			      ((funcall ,compare value key)
			       (setf right-child (rec right-child))
			       (,node-update-height node)
			       (,node-make-balance-left node))
			      (t node)))))
	     (setf root (rec root)))))
       (defun ,set-erase (set key)
	 (declare (,set set) (,element-type key))
	 (with-slots (count root) set
	   (labels ((rec (node key)
		      (declare ((or null ,node) node) (,element-type key))
		      (unless node
			(return-from rec nil))
		      (with-slots (left-child right-child value) node
			(cond ((funcall ,compare key value)
			       (setf left-child (rec left-child key))
			       (,node-update-height node)
			       (,node-make-balance-left node))
			      ((funcall ,compare value key)
			       (setf right-child (rec right-child key))
			       (,node-update-height node)
			       (,node-make-balance-right node))
			      (t
			       (cond (right-child
				      (let ((minimum (minimum right-child)))
					(setf (,node-value node) minimum)
					(setf right-child (rec right-child minimum))
					(,node-update-height node)
					(,node-make-balance-right node)))
				     (t (decf count)
					left-child))))))
		    (minimum (node)
		      (declare (,node node))
		      (with-slots (left-child) node
			(if left-child
			    (minimum left-child)
			    (,node-value node)))))
	     (setf root (rec root key)))))
       (defun ,set-find (set key)
	 (with-slots (root) set
	   (labels ((rec (node)
		      (declare ((or null ,node) node))
		      (unless node (return-from rec nil))
		      (with-slots (left-child right-child value) node
			(cond ((funcall ,compare key value)
			       (rec left-child))
			      ((funcall ,compare value key)
			       (rec right-child))
			      (t
			       node)))))
	     (rec root))))
       (defun ,set-has (set key)
	 (declare (,set set) (,element-type key))
	 (with-slots (root) set
	   (labels ((rec (node)
		      (declare ((or null ,node) node))
		      (unless node (return-from rec nil))
		      (with-slots (left-child right-child value) node
			(cond ((funcall ,compare key value)
			       (rec left-child))
			      ((funcall ,compare value key)
			       (rec right-child))
			      (t
			       t)))))
	     (rec root))))
       )
    )
  )

(in-package :cl-user)

;;(print (macroexpand-1 '(avl-tree:define-avl-set myset :element-type integer)))
(avl-tree:define-avl-set myset :element-type integer)

(defun main ()
  #+swank(sb-profile:reset)
  #+swank(sb-profile:profile "CL-USER")
  (time (let* ((set (make-myset))
	       (n 1000000))
	  (dotimes (i n)
	    (myset-insert set (mod (* i i) n)))))
  #+swank(sb-profile:report))

(main)
